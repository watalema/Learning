#1.


#2.两数相加
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

#我的解法：分为3部分完成，代码量大
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        sum1=0
        sum2=0
        k1=1
        k2=1
        while l1!=None:
            sum1+=l1.val*k1
            k1*=10
            l1=l1.next
        while l2!=None:
            sum1+=l2.val*k2
            k2*=10
            l2=l2.next
        sum=sum1+sum2
        sum_str=str(sum)
        sum_str=sum_str[::-1]
        rtn_head=ListNode(int(sum_str[0]))
        node=rtn_head
        for i in range(1,len(sum_str)):
            node.next=ListNode(int(sum_str[i]))
            node=node.next
        return rtn_head
		
#优秀解法,加法的过程，用carry作为进位标志
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        tmp=ListNode(-1)
        p,q,cur=l1,l2,tmp
        carry=0
        while p or q:
            x=p.val if p else 0
            y=q.val if q else 0
            s=x+y+carry
            carry=s//10
            cur.next=ListNode(s%10)
            cur=cur.next
            if p:
                p=p.next
            if q:
                q=q.next
        if carry>0:
            cur.next=ListNode(carry)
        return tmp.next


#3.无重复的最长子串
#我的解法：O(n^2),以每个字母开头求不重复子串，取最长的子串
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        max_str=''
        n=len(s)
        if s=='':
            return 0
        for i in range(n):
            tmp_str=''
            for j in range(i,n):
                if s[j] not in tmp_str:
                    tmp_str+=s[j]
                else:
                    break
            if len(max_str)<len(tmp_str):
                max_str=tmp_str
        return len(max_str)
#优秀解法：截取重复字母后的子串继续添加不重复的字母
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if s=='':
            return 0
        max_len=1
        tmp_str=''
        for i in s:
            if i in tmp_str:
                if i ==tmp_str[-1]:
                    tmp_str=i
                else:
                    k=tmp_str.index(i)
                    tmp_str=tmp_str[k+1:]+i
            else:
                tmp_str+=i
                if max_len<len(tmp_str):
                    max_len=len(tmp_str)
        return max_len
		

4.两个有序数组的中位数
我的解法：
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        nums=nums1+nums2
        nums.sort()
        n=len(nums)
        if n%2:
            rtn=float(nums[n//2])
        else:
            rtn=float((nums[n//2]+nums[n//2-1])/2)
        return rtn
