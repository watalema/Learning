#电话号码的字母组合
#这是别人的解答，递归实现深度优先搜索
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        mapping={
            '2':'abc',
            '3':'def',
            '4':'ghi',
            '5':'jkl',
            '6':'mno',
            '7':'pqrs',
            '8':'tuv',
            '9':'wxyz'
        }
        rtn=[]
        def BackTracking(idx,path=''):
            if idx==len(digits):return rtn.append(path)
            for i in mapping[digits[idx]]:BackTracking(idx+1,path+i)
        BackTracking(0)
        return rtn
        
#别人的解法2：迭代
class Solution:
    def letterCombinations(self,digits):
        if not digits: return []
        map = {'2': ['a', 'b', 'c'], '3': ['d', 'e', 'f'], '4': ['g', 'h', 'i'], '5': ['j', 'k', 'l'],
               '6': ['m', 'n', 'o'],
               '7': ['p', 'q', 'r', 's'], '8': ['t', 'u', 'v'], '9': ['w', 'x', 'y', 'z'], }
        ret = []
        for n in digits:
            if not ret:
                for i in map[n]:ret.append(i)
            else:
                tmp=[]
                for j in ret:
                    for k in map[n]:
                        tmp.append(j+k)
                ret=tmp
        return ret
#四数相加
#我的解法：借鉴三数之和，内存和时间消耗大，借鉴之前的加速方法，但是频频出错
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        rtn = []
        if n < 4: return rtn
        for i in range(n):
            if i and nums[i] == nums[i - 1]: continue
            for j in range(i+1, n):
                #if nums[i]+nums[j]>target:continue
                l = j + 1
                r = n - 1
                while l < r:
                    tmp=[nums[i],nums[j], nums[l], nums[r]]
                    if nums[i] + nums[j] + nums[l] + nums[r] == target and tmp not in rtn:
                        rtn.append([nums[i],nums[j], nums[l], nums[r]])
                        l += 1
                        r -= 1
                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:
                        l += 1
                    else:
                        r -=1
        return rtn
#优秀解法：
class Solution:
    def fourSum(self, nums, target):
        def Nsum(nums, target, N, result, results):
            if len(nums) < N or N < 2 or nums[0]*N > target or nums[-1]*N < target:
                return
            if N == 2:
                l, r = 0, len(nums) - 1
                while l < r:
                    s = nums[l] + nums[r]
                    if s == target:
                        results.append(result + [nums[l], nums[r]])
                        l += 1
                        while l < r and nums[l] == nums[l-1]:
                            l += 1
                    elif s < target:
                        l += 1
                    else:
                        r -= 1
            else:
                for i in range(len(nums) - N + 1):
                    if i == 0 or (i > 0 and nums[i-1] != nums[i]):
                        Nsum(nums[i+1:], target - nums[i], N-1, result+[nums[i]], results)

        results = []
        Nsum(sorted(nums), target, 4, [], results)
        return results
